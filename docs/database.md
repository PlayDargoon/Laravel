# Laravel 9 · База данных · Начало работы

- [Введение](#introduction)
    - [Конфигурирование](#configuration)
    - [Соединения для чтения и записи](#read-and-write-connections)
- [Выполнение SQL-запросов](#running-queries)
    - [Использование нескольких соединений к базе данных](#using-multiple-database-connections)
    - [Прослушивание событий запроса](#listening-for-query-events)
    - [Мониторинг совокупного времени запроса](#monitoring-cumulative-query-time)
- [Транзакции базы данных](#database-transactions)
- [Подключение к базе данных с помощью интерфейса командной строки](#connecting-to-the-database-cli)
- [Просмотр сведений ваших баз данных](#inspecting-your-databases)
- [Мониторинг ваших баз данных](#monitoring-your-databases)

<a name="introduction"></a>
## Введение

Почти каждое современное веб-приложение взаимодействует с базой данных. Laravel делает взаимодействие с базами данных чрезвычайно простым через поддержку множества баз данных, используя либо сырой SQL [построителя запросов](queries.md), либо [Eloquent ORM](eloquent.md). В настоящее время Laravel обеспечивает поддержку пяти баз данных:

<!-- <div class="content-list" markdown="1"> -->

- MariaDB 10.3+ ([Политика версий](https://mariadb.org/about/#maintenance-policy))
- MySQL 5.7+ ([Политика версий](https://en.wikipedia.org/wiki/MySQL#Release_history))
- PostgreSQL 10.0+ ([Политика версий](https://www.postgresql.org/support/versioning/))
- SQLite 3.8.8+
- SQL Server 2017+ ([Политика версий](https://docs.microsoft.com/en-us/lifecycle/products/?products=sql-server))

<!-- </div> -->

<a name="configuration"></a>
### Конфигурирование

Конфигурация служб баз данных Laravel находится в конфигурационном файле `config/database.php` вашего приложения. В этом файле вы можете определить все соединения к базе данных, а также указать, какое соединение должно использоваться по умолчанию. Большинство параметров конфигурации в этом файле определяется значениями переменных окружения вашего приложения. В этом файле представлены примеры для большинства систем баз данных, поддерживаемых Laravel.

По умолчанию пример [конфигурации окружения](configuration.md#environment-configuration) Laravel готов к использованию с [Laravel Sail](sail.md), который представляет собой конфигурацию Docker для разработки приложений Laravel на вашем локальном компьютере. Однако вы можете изменить конфигурацию своей базы данных по мере необходимости для своей локальной базы данных.

<a name="sqlite-configuration"></a>
#### Конфигурация SQLite

Базы данных SQLite содержатся в одном файле вашей файловой системы. Вы можете создать новую базу данных SQLite, используя команду `touch` в консоли: `touch database/database.sqlite`. После создания базы данных вы можете легко настроить переменные окружения так, чтобы они указывали на эту базу данных, указав абсолютный путь к базе данных в переменной `DB_DATABASE` окружения:

```ini
DB_CONNECTION=sqlite
DB_DATABASE=/absolute/path/to/database.sqlite
```

Чтобы включить ограничения внешнего ключа для соединений SQLite, установите переменную `DB_FOREIGN_KEYS` окружения в `true`:

```ini
DB_FOREIGN_KEYS=true
```

<a name="mssql-configuration"></a>
#### Конфигурация Microsoft SQL Server

Чтобы использовать базу данных Microsoft SQL Server, вы должны убедиться, что у вас установлены расширения PHP `sqlsrv` и `pdo_sqlsrv`, а также любые зависимости, которые могут им потребоваться, например, драйвер Microsoft SQL ODBC.

<a name="configuration-using-urls"></a>
#### Конфигурация с использованием URL

Обычно соединения с базой данных конфигурируются с использованием нескольких значений, таких как `host`, `database`, `username`, `password` и т.д. Каждое из этих значений имеет свою собственную соответствующую переменную окружения. Это означает, что при указании информации о соединении с базой данных на рабочем веб-сервере вам необходимо управлять несколькими переменными окружения.

Некоторые поставщики СУБД, такие как AWS и Heroku, предоставляют единый «URL» базы данных, который содержит всю информацию о соединении в одной строке. Пример URL-адреса базы данных может выглядеть так:

```html
mysql://root:password@127.0.0.1/forge?charset=UTF-8
```

Эти URL обычно следуют соглашению стандартной схемы:

```html
driver://username:password@host:port/database?options
```

Для удобства Laravel поддерживает эти URL-адреса в качестве альтернативы настройке базы данных с несколькими параметрами конфигурации. Если присутствует параметр конфигурации `url` (или соответствующая переменная `DATABASE_URL` окружения), то он будет использоваться для получения информации о соединении с базой данных и об учетных данных.

<a name="read-and-write-connections"></a>
### Соединения для чтения и записи

По желанию можно использовать одно соединение с базой данных для операторов `SELECT`, а другое – для операторов `INSERT`, `UPDATE` и `DELETE`. Laravel упрощает эту задачу, и всегда будут использоваться соответствующие соединения, независимо от того, используете ли вы сырые запросы построителя запросов или Eloquent ORM.

Чтобы увидеть, как должны быть настроены соединения для чтения / записи, давайте посмотрим на этот пример:

    'mysql' => [
        'read' => [
            'host' => [
                '192.168.1.1',
                '196.168.1.2',
            ],
        ],
        'write' => [
            'host' => [
                '196.168.1.3',
            ],
        ],
        'sticky' => true,
        'driver' => 'mysql',
        'database' => 'database',
        'username' => 'root',
        'password' => '',
        'charset' => 'utf8mb4',
        'collation' => 'utf8mb4_unicode_ci',
        'prefix' => '',
    ],

Обратите внимание, что в массив конфигурации были добавлены три ключа: `read`, `write` и `sticky`. Ключи `read` и `write` имеют значения массива, содержащие один ключ: `host`. Остальные параметры базы данных для соединений `read` и `write` будут объединены из основного массива конфигурации `mysql`.

В массивы `read` и `write` вам нужно помещать только те элементы, значения которых вы хотите переопределить из основного массива `mysql`. Таким образом, в этом случае `192.168.1.1` будет использоваться в качестве хоста для соединения «чтение», а `192.168.1.3` – для соединения «запись». Учетные данные БД, префикс, набор символов и все другие параметры из основного массива `mysql` будут совместно использоваться обоими соединениями. Если в массиве конфигурации `host` существует несколько значений, то для каждого запроса хост базы данных будет выбран случайным образом.

<a name="the-sticky-option"></a>
#### Параметр `sticky`

Параметр `sticky` – это *необязательное* значение, которое может использоваться для разрешения немедленного чтения записей, которые были записаны в базу данных во время текущего цикла запроса. Если опция `sticky` включена и в текущем цикле запроса к базе данных была выполнена операция «записи», то любые дальнейшие операции «чтения» будут использовать соединение «запись». Это гарантирует, что любые данные, записанные во время цикла запроса, могут быть немедленно обратно прочитаны из базы данных во время того же запроса. Вам решать, является ли это желаемым поведением для вашего приложения.

<a name="running-queries"></a>
## Выполнение SQL-запросов

После того, как вы настроили соединение с базой данных, вы можете выполнять запросы, используя фасад `DB`. Фасад `DB` содержит методы для каждого типа запроса: `select`, `update`, `insert`, `delete` и `statement`.

<a name="running-a-select-query"></a>
#### Выполнение Select-запроса

Чтобы выполнить базовый запрос `SELECT`, вы можете использовать метод `select` фасада `DB`:

    <?php

    namespace App\Http\Controllers;

    use App\Http\Controllers\Controller;
    use Illuminate\Support\Facades\DB;

    class UserController extends Controller
    {
        /**
         * Показать список всех пользователей приложения.
         *
         * @return \Illuminate\Http\Response
         */
        public function index()
        {
            $users = DB::select('select * from users where active = ?', [1]);

            return view('user.index', ['users' => $users]);
        }
    }

Первым аргументом, переданным методу `select`, является SQL-запрос, а вторым аргументом – любые привязки параметров, необходимые для запроса. Обычно это значения ограничений выражений `where`. Привязка параметров обеспечивает защиту от SQL-инъекций.

Метод `select` всегда возвращает «массив» результатов. Каждый результат в массиве будет объектом `stdClass` PHP, представляющим запись из базы данных:

    use Illuminate\Support\Facades\DB;

    $users = DB::select('select * from users');

    foreach ($users as $user) {
        echo $user->name;
    }

<a name="selecting-scalar-values"></a>
#### Выборка скалярных значений

Иногда запрос к базе данных может вернуть единственное скалярное значение. Вместо того, чтобы извлекать результат из объекта записи, Laravel позволяет вам получить это значение напрямую, используя метод `scalar`:

    $burgers = DB::scalar(
        "select count(case when food = 'burger' then 1 end) as burgers from menu"
    );

<a name="using-named-bindings"></a>
#### Использование именованных псевдопеременных

Вместо использования символа `?` для связывания параметров вы можете выполнить запрос, используя именованные привязки:

    $results = DB::select('select * from users where id = :id', ['id' => 1]);

<a name="running-an-insert-statement"></a>
#### Выполнение Insert-запроса

Чтобы выполнить запрос с `INSERT`, вы можете использовать метод `insert` фасада `DB`. Как и `select`, этот метод принимает запрос SQL в качестве первого аргумента, а привязки – в качестве второго аргумента:

    use Illuminate\Support\Facades\DB;

    DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);

<a name="running-an-update-statement"></a>
#### Выполнение Update-запроса

Метод `update` следует использовать для обновления существующих записей в базе данных. Количество затронутых выражением строк будут возвращены этим методом:

    use Illuminate\Support\Facades\DB;

    $affected = DB::update(
        'update users set votes = 100 where name = ?',
        ['Anita']
    );

<a name="running-a-delete-statement"></a>
#### Выполнение Delete-запроса

Для удаления записей из базы данных следует использовать метод `delete`. Как и `update`, количество затронутых выражением строк будут возвращены этим методом:

    use Illuminate\Support\Facades\DB;

    $deleted = DB::delete('delete from users');

<a name="running-a-general-statement"></a>
#### Выполнение запроса общего типа

Некоторые операторы базы данных не возвращают никакого значения. Для этих типов операций вы можете использовать метод `statement` фасада `DB`:

    DB::statement('drop table users');

<a name="running-an-unprepared-statement"></a>
#### Выполнение неподготовленного запроса

Иногда требуется выполнить запрос SQL без привязки каких-либо значений. Для этого используйте метод `unprepared` фасада `DB`:

    DB::unprepared('update users set votes = 100 where name = "Dries"');

> **Предупреждение**\
> Поскольку неподготовленные запросы не связывают параметры, они могут быть уязвимы для SQL-инъекций. Вы никогда не должны пропускать в неподготовленное выражение значения, управляемые пользователем.

<a name="implicit-commits-in-transactions"></a>
#### Неявные фиксации

При использовании в транзакциях методов `statement` и `unprepared` фасада `DB` вы должны быть осторожны, чтобы избежать операторов, которые вызывают [неявные фиксации](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html). Эти операторы заставят ядро базы данных косвенно зафиксировать всю транзакцию, в результате чего Laravel не будет знать об уровне транзакции базы данных. Примером такого оператора является создание таблицы базы данных:

    DB::unprepared('create table a (col varchar(1) null)');

Пожалуйста, обратитесь к руководству по MySQL для ознакомления со [списком всех операторов](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html), которые выполняют неявные фиксации.

<a name="using-multiple-database-connections"></a>
### Использование нескольких соединений к базе данных

Если ваше приложение определяет несколько соединений в конфигурационном файле `config/database.php`, то вы можете получить доступ к каждому соединению с помощью метода `connection` фасада `DB`. Имя соединения, передаваемое методу `connection`, должно соответствовать одному из подключений, перечисленных в вашем конфигурационном файле `config/database.php`, включая переопределенные с помощью глобального помощника `config` во время выполнения скрипта:

    use Illuminate\Support\Facades\DB;

    $users = DB::connection('sqlite')->select(/* ... */);

Вы можете получить доступ к сырому, базовому экземпляру PDO текущего соединения, используя метод `getPdo` экземпляра соединения:

    $pdo = DB::connection()->getPdo();

<a name="listening-for-query-events"></a>
### Прослушивание событий запроса

По желанию можно указать замыкание, которое будет вызываться для каждого SQL-запроса, выполняемого вашим приложением, используя метод `listen` фасада `DB`. Этот метод может быть полезен для логирования запросов или их отладки. Как правило, регистрация замыкания слушателя запросов осуществляется в методе `boot` [поставщика служб](providers.md):

    <?php

    namespace App\Providers;

    use Illuminate\Support\Facades\DB;
    use Illuminate\Support\ServiceProvider;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Регистрация любых служб приложения.
         *
         * @return void
         */
        public function register()
        {
            //
        }

        /**
         * Загрузка любых служб приложения.
         *
         * @return void
         */
        public function boot()
        {
            DB::listen(function ($query) {
                // $query->sql;
                // $query->bindings;
                // $query->time;
            });
        }
    }

<a name="monitoring-cumulative-query-time"></a>
### Мониторинг совокупного времени запроса

Общим узким местом производительности современных веб-приложений является количество времени, которое они тратят на запросы к базам данных. К счастью, Laravel может вызвать замыкание, когда тратится слишком много времени на запросы к базе данных в рамках одного запроса к приложению. Для начала укажите пороговое значение времени запроса (в миллисекундах) и замыкание для метода `whenQueryingForLongerThan`. Как правило, вызов этого метода осуществляется в методе `boot` [поставщика служб](providers.md):

    <?php

    namespace App\Providers;

    use Illuminate\Database\Connection;
    use Illuminate\Support\Facades\DB;
    use Illuminate\Support\ServiceProvider;
    use Illuminate\Database\Events\QueryExecuted;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Регистрация любых служб приложения.
         *
         * @return void
         */
        public function register()
        {
            //
        }

        /**
         * Загрузка любых служб приложения.
         *
         * @return void
         */
        public function boot()
        {
            DB::whenQueryingForLongerThan(500, function (Connection $connection, QueryExecuted $event) {
                // Уведомить команду разработчиков ...
            });
        }
    }

<a name="database-transactions"></a>
## Транзакции базы данных

Вы можете использовать метод `transaction` фасада `DB`, для выполнения набора операций в транзакции базы данных. Если внутри замыкания транзакции возникает исключение, то транзакция автоматически откатывается, а исключение генерируется повторно. Если замыкание выполнено успешно, то транзакция будет автоматически зафиксирована. Вам не нужно беспокоиться о ручном откате или фиксации при использовании метода `transaction`:

    use Illuminate\Support\Facades\DB;

    DB::transaction(function () {
        DB::update('update users set votes = 1');

        DB::delete('delete from posts');
    });

<a name="handling-deadlocks"></a>
#### Обработка взаимоблокировок

Метод `transaction` принимает необязательный второй аргумент, который определяет, сколько раз транзакция должна быть повторена при возникновении взаимоблокировок. Как только эти попытки будут исчерпаны, будет выброшено исключение:

    use Illuminate\Support\Facades\DB;

    DB::transaction(function () {
        DB::update('update users set votes = 1');

        DB::delete('delete from posts');
    }, 5);

<a name="manually-using-transactions"></a>
#### Использование транзакций вручную

Если вы хотите вручную начать транзакцию и иметь полный контроль над откатами и фиксациями, то вы можете использовать метод `beginTransaction` фасада `DB`:

    use Illuminate\Support\Facades\DB;

    DB::beginTransaction();

Вы можете откатить транзакцию с помощью метода `rollBack`:

    DB::rollBack();

Наконец, вы можете зафиксировать транзакцию с помощью метода `commit`:

    DB::commit();

> **Примечание**\
> Методы транзакций фасада `DB` контролируют транзакции как для [построителя запросов](queries.md), так и для [Eloquent ORM](eloquent.md).

<a name="connecting-to-the-database-cli"></a>
## Подключение к базе данных с помощью интерфейса командной строки

Если вы хотите подключиться к своей базе данных с помощью интерфейса командной строки, то вы можете использовать команду `db` Artisan:

```shell
php artisan db
```

При необходимости, вы можете указать имя соединения для подключения к базе данных, не являющееся соединением по умолчанию:

```shell
php artisan db mysql
```

<a name="inspecting-your-databases"></a>
## Просмотр сведений ваших баз данных

Используя команды `db:show` и `db:table` Artisan, вы можете получить ценную информацию о своей базе данных и связанных с ней таблицах. Чтобы просмотреть свойства вашей базы данных, включая ее размер, тип, количество открытых подключений и сводку по таблицам, вы можете использовать команду `db:show`:

```shell
php artisan db:show
```

Вы можете указать, какое соединение с базой данных следует просмотреть, указав имя соединения с базой данных с помощью параметра `--database`:

```shell
php artisan db:show --database=pgsql
```

Если вы хотите включить количество строк в таблице и сведения о представлении базы данных в вывод команды, то вы можете указать параметры `--counts` и `--views` соответственно. В больших базах данных получение количества строк и сведений о представлениях может быть медленным:

```shell
php artisan db:show --counts --views
```

<a name="table-overview"></a>
#### Table Overview

Если вы хотите получить обзор отдельной таблицы в вашей базе данных, то вы можете выполнить команду `db:table` Artisan. Эта команда предоставляет общий обзор таблицы базы данных, включая ее столбцы, типы, атрибуты, ключи и индексы:

```shell
php artisan db:table users
```

<a name="monitoring-your-databases"></a>
## Мониторинг ваших баз данных

Используя команду `db:monitor` Artisan, вы можете указать Laravel инициировать событие `Illuminate\Database\Events\DatabaseBusy`, если ваша база данных управляет более чем указанным количеством открытых соединений.

Для начала вы должны запланировать команду `db:monitor` так, чтобы она [запускалась каждую минуту](scheduling.md). Команда принимает имена конфигураций подключения к базе данных, которые вы хотите отслеживать, а также максимальное количество открытых подключений, которое должно быть разрешено перед отправкой события:

```shell
php artisan db:monitor --databases=mysql,pgsql --max=100
```

Одного планирования этой команды недостаточно, чтобы отправить уведомление, предупреждающее вас о количестве открытых подключений. Когда команда обнаруживает базу данных, количество открытых подключений которой превышает пороговое значение, тогда будет инициировано событие `DatabaseBusy`. Вы должны прослушивать это событие в `EventServiceProvider` вашего приложения, чтобы отправить уведомление вам или вашей команде разработчиков:

```php
use App\Notifications\DatabaseApproachingMaxConnections;
use Illuminate\Database\Events\DatabaseBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;

/**
 * Регистрация любых событий вашего приложения.
 *
 * @return void
 */
public function boot()
{
    Event::listen(function (DatabaseBusy $event) {
        Notification::route('mail', 'dev@example.com')
                ->notify(new DatabaseApproachingMaxConnections(
                    $event->connectionName,
                    $event->connections
                ));
    });
}
```
