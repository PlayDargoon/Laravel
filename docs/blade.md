# Laravel 9 · Шаблонизатор Blade

- [Введение](#introduction)
    - [Использование Blade с Livewire](#supercharging-blade-with-livewire)
- [Отображение данных](#displaying-data)
    - [Преобразование в HTML-сущности](#html-entity-encoding)
    - [Blade и JavaScript фреймворки](#blade-and-javascript-frameworks)
- [Директивы Blade](#blade-directives)
    - [Операторы If](#if-statements)
    - [Операторы Switch](#switch-statements)
    - [Циклы](#loops)
    - [Переменная Loop](#the-loop-variable)
    - [Условные классы](#conditional-classes)
    - [Дополнительные атрибуты](#additional-attributes)
    - [Подключение дочерних шаблонов](#including-subviews)
    - [Директива `@once`](#the-once-directive)
    - [Необработанный PHP](#raw-php)
    - [Комментарии](#comments)
- [Компоненты](#components)
    - [Отрисовка компонентов](#rendering-components)
    - [Передача данных компонентам](#passing-data-to-components)
    - [Атрибуты компонента](#component-attributes)
    - [Зарезервированные ключевые слова](#reserved-keywords)
    - [Слоты](#slots)
    - [Встроенные шаблоны компонентов](#inline-component-views)
    - [Динамические компоненты](#dynamic-components)
    - [Самостоятельная регистрация компонентов](#manually-registering-components)
- [Анонимные компоненты](#anonymous-components)
    - [Анонимные составные компоненты](#anonymous-index-components)
    - [Свойства / атрибуты данных](#data-properties-attributes)
    - [Доступ к данным родительского компонента](#accessing-parent-data)
    - [Пути анонимных компонентов](#anonymous-component-paths)
- [Создание макетов](#building-layouts)
    - [Макеты с использованием компонентов](#layouts-using-components)
    - [Макеты с использованием наследования шаблонов](#layouts-using-template-inheritance)
- [Формы](#forms)
    - [Поле CSRF](#csrf-field)
    - [Поле Method](#method-field)
    - [Ошибки валидации](#validation-errors)
- [Стеки](#stacks)
- [Внедрение служб](#service-injection)
- [Отрисовка встроенных шаблонов Blade](#rendering-inline-blade-templates)
- [Отрисовка фрагментов Blade](#rendering-blade-fragments)
- [Расширение Blade](#extending-blade)
    - [Пользовательские обработчики вывода](#custom-echo-handlers)
    - [Пользовательские операторы If](#custom-if-statements)

<a name="introduction"></a>
## Введение

Blade – это простой, но мощный движок шаблонов, входящий в состав Laravel. В отличие от некоторых шаблонизаторов PHP, Blade не ограничивает вас в использовании простого кода PHP в ваших шаблонах. На самом деле, все шаблоны Blade компилируются в простой код PHP и кешируются до тех пор, пока не будут изменены, что означает, что Blade добавляет фактически нулевую нагрузку вашему приложению. Файлы шаблонов Blade используют расширение файла `.blade.php` и обычно хранятся в каталоге `resources/views`.

Шаблоны Blade могут быть возвращены из маршрутов или контроллеров с помощью глобального помощника `view`. Конечно, как упоминалось в документации по [HTML-шаблонам](views.md), данные могут быть переданы в шаблоны Blade, используя второй аргумент помощника `view`:

    Route::get('/', function () {
        return view('greeting', ['name' => 'Finn']);
    });

<a name="supercharging-blade-with-livewire"></a>
### Использование Blade с Livewire

Хотите вывести использование шаблонов Blade на новый уровень и с легкостью создавать динамические интерфейсы? Ознакомьтесь с [Laravel Livewire](https://laravel-livewire.com). Livewire позволяет вам писать компоненты Blade, которые дополнены динамической функциональностью интерфейсных фреймворков, таких как React или Vue, и обеспечивает отличный подход к созданию современных интерфейсов без сложностей многих фреймворков JavaScript, таких как рендеринг на клиентской стороне или этапов их сборки.

<a name="displaying-data"></a>
## Отображение данных

Вы можете отображать данные, которые передаются в шаблоны Blade, заключив переменную в фигурные скобки. Например, учитывая следующий маршрут:

    Route::get('/', function () {
        return view('welcome', ['name' => 'Samantha']);
    });

Вы можете отобразить содержимое переменной `name` следующим образом:

```blade
Hello, {{ $name }}.
```

> **Примечание**\
> Выражения вывода `{{ }}` Blade автоматически отправляются через функцию `htmlspecialchars` PHP для предотвращения XSS-атак.

Вы не ограничены отображением содержимого переменных, переданных в шаблон. Вы также можете вывести результаты любой функции PHP. Фактически, вы можете поместить любой PHP-код в выражение вывода Blade:

```blade
The current UNIX timestamp is {{ time() }}.
```

<a name="html-entity-encoding"></a>
### Преобразование в HTML-сущности

По умолчанию Blade (и глобальный помощник `e` Laravel) будет дважды кодировать объекты HTML. Если вы хотите отключить двойное кодирование, то вызовите метод `Blade::withoutDoubleEncoding` в методе `boot` поставщика `App\Providers\AppServiceProvider`:

    <?php

    namespace App\Providers;

    use Illuminate\Support\Facades\Blade;
    use Illuminate\Support\ServiceProvider;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Загрузка любых служб приложения.
         *
         * @return void
         */
        public function boot()
        {
            Blade::withoutDoubleEncoding();
        }
    }

<a name="displaying-unescaped-data"></a>
#### Вывод неэкранированных данных

По умолчанию, выражения вывода `{{ }}` Blade автоматически отправляются через функцию `htmlspecialchars` PHP для предотвращения XSS-атак. Если вы не хотите, чтобы ваши данные были экранированы, вы можете использовать следующий синтаксис:

```blade
Hello, {!! $name !!}.
```

> **Предупреждение**\
> Будьте очень осторожны при выводе содержимого, полученного от пользователей вашего приложения. Обычно следует использовать экранированный синтаксис двойных фигурных скобок для предотвращения атак XSS при отображении данных, предоставленных пользователем.

<a name="blade-and-javascript-frameworks"></a>
### Blade и JavaScript фреймворки

Поскольку во многих фреймворках JavaScript также используются «фигурные» скобки, чтобы указать, что данное выражение должно отобразиться в браузере, вы можете использовать символ `@`, чтобы сообщить движку Blade, что выражение должно остаться нетронутым. Например:

```blade
<h1>Laravel</h1>

Hello, @{{ name }}.
```

В этом примере Blade удалит символ `@`; однако выражение `{{ name }}` останется нетронутым движком Blade, что позволит обработать его вашим фреймворком JavaScript.

Символ `@` также используется для исключения из обработки директив Blade:

```blade
{{-- Шаблон Blade --}}
@@if()

<!-- Вывод HTML -->
@if()
```

<a name="rendering-json"></a>
#### Вывод JSON

Вы можете передать массив в ваш шаблон с намерением отобразить его как JSON для инициализации переменной JavaScript. Например:

```blade
<script>
    var app = <?php echo json_encode($array); ?>;
</script>
```

Однако вместо ручного вызова `json_encode` вы можете использовать метод `Illuminate\Support\Js::from`. Метод `from` принимает те же аргументы, что и функция `json_encode` PHP; однако это гарантирует, что полученный JSON будет правильно экранирован кавычками HTML. Метод `from` вернет строковое выражение `JSON.parse` JavaScript, которое преобразует переданный объект или массив в допустимый объект JavaScript:

```blade
<script>
    var app = {{ Illuminate\Support\Js::from($array) }};
</script>
```

Последние версии приложения Laravel включают фасад `Js`, который обеспечивает удобный доступ к этому функционалу в ваших шаблонах Blade:

```blade
<script>
    var app = {{ Js::from($array) }};
</script>
```

> **Предупреждение**\
> Вы должны использовать метод `Js::from` только для отображения существующих переменных как JSON. Шаблонизатор Blade основан на регулярных выражениях, и попытки передать сложное выражение в метод могут вызвать неожиданные сбои.

<a name="the-at-verbatim-directive"></a>
#### Директива `@verbatim`

Если вы отображаете переменные JavaScript в крупной части своего шаблона, вы можете заключить HTML в директиву `@verbatim`, чтобы вам не приходилось добавлять префикс `@` к каждому выражению вывода Blade:

```blade
@verbatim
    <div class="container">
        Hello, {{ name }}.
    </div>
@endverbatim
```

<a name="blade-directives"></a>
## Директивы Blade

Помимо наследования шаблонов и отображения данных, Blade также содержит удобные псевдонимы для общих структур управления PHP, таких как условные операторы и циклы. Эти директивы обеспечивают очень чистый и лаконичный способ работы со структурами управления PHP, но при этом остаются схожими со своими аналогами PHP.

<a name="if-statements"></a>
### Операторы If

Вы можете создавать операторы `if`, используя директивы `@if`, `@elseif`, `@else` и `@endif`. Эти директивы работают так же, как и их аналоги в PHP:

```blade
@if (count($records) === 1)
    I have one record!
@elseif (count($records) > 1)
    I have multiple records!
@else
    I don't have any records!
@endif
```

Для удобства Blade также содержит директиву `@unless`:

```blade
@unless (Auth::check())
    You are not signed in.
@endunless
```

В дополнение к уже обсужденным условным директивам, директивы `@isset` и `@empty` могут использоваться в качестве удобных ярлыков для соответствующих функций PHP:

```blade
@isset($records)
    // Переменная $records определена и не равна `null` ...
@endisset

@empty($records)
    // Переменная $records считается «пустой» ...
@endempty
```

<a name="authentication-directives"></a>
#### Директивы аутентификации

Директивы `@auth` и `@guest` могут использоваться для быстрого определения, является ли текущий пользователь [аутентифицированным](authentication.md) или считается гостем:

```blade
@auth
    // Пользователь аутентифицирован ...
@endauth

@guest
    // Пользователь не аутентифицирован ...
@endguest
```

При необходимости вы можете указать охранника аутентификации для проверки при использовании директив `@auth` и `@guest`:

```blade
@auth('admin')
    // Пользователь аутентифицирован ...
@endauth

@guest('admin')
    // Пользователь не аутентифицирован ...
@endguest
```

<a name="environment-directives"></a>
#### Директивы окружения

Вы можете проверить, запущено ли приложение в эксплуатационном окружении, с помощью директивы `@production`:

```blade
@production
    // Содержимое, отображаемое только в эксплуатационном окружении ...
@endproduction
```

Или вы можете определить, работает ли приложение в конкретной среде, с помощью директивы `@env`:

```blade
@env('staging')
    // Приложение запущено в «переходном» окружении ...
@endenv

@env(['staging', 'production'])
    // Приложение запущено в «переходном» или «рабочем» окружении ...
@endenv
```

<a name="section-directives"></a>
#### Директивы секций

Вы можете определить, есть ли в секции наследуемого шаблона содержимое, используя директиву `@hasSection`:

```blade
@hasSection('navigation')
    <div class="pull-right">
        @yield('navigation')
    </div>

    <div class="clearfix"></div>
@endif
```

Вы можете использовать директиву `sectionMissing`, чтобы определить, что в секции нет содержимого:

```blade
@sectionMissing('navigation')
    <div class="pull-right">
        @include('default-navigation')
    </div>
@endif
```

<a name="switch-statements"></a>
### Операторы Switch

Операторы Switch могут быть созданы с использованием директив `@switch`, `@case`, `@break`, `@default` и `@endswitch`:

```blade
@switch($i)
    @case(1)
        First case...
        @break

    @case(2)
        Second case...
        @break

    @default
        Default case...
@endswitch
```

<a name="loops"></a>
### Циклы

В дополнение к условным операторам, Blade содержит простые директивы для работы со структурами циклов PHP. Опять же, каждая из этих директив работает так же, как и их аналоги в PHP:

```blade
@for ($i = 0; $i < 10; $i++)
    The current value is {{ $i }}
@endfor

@foreach ($users as $user)
    <p>This is user {{ $user->id }}</p>
@endforeach

@forelse ($users as $user)
    <li>{{ $user->name }}</li>
@empty
    <p>No users</p>
@endforelse

@while (true)
    <p>I'm looping forever.</p>
@endwhile
```

> **Примечание**\
> При итерации с помощью `foreach` вы можете использовать [переменную Loop](#the-loop-variable), чтобы получить информацию о цикле, например, находитесь ли вы в первой или последней итерации цикла.

Вы также можете пропустить текущую итерацию или завершить цикл, используя директивы `@continue` и `@break`:

```blade
@foreach ($users as $user)
    @if ($user->type == 1)
        @continue
    @endif

    <li>{{ $user->name }}</li>

    @if ($user->number == 5)
        @break
    @endif
@endforeach
```

Вы также можете включить в объявление директивы условие продолжения или прерывания:

```blade
@foreach ($users as $user)
    @continue($user->type == 1)

    <li>{{ $user->name }}</li>

    @break($user->number == 5)
@endforeach
```

<a name="the-loop-variable"></a>
### Переменная Loop

При итерации с помощью `foreach` внутри цикла доступна переменная `$loop`. Она обеспечивает доступ к некоторой полезной информации, например, индекс текущего цикла, первая это или последняя итерация цикла:

```blade
@foreach ($users as $user)
    @if ($loop->first)
        This is the first iteration.
    @endif

    @if ($loop->last)
        This is the last iteration.
    @endif

    <p>This is user {{ $user->id }}</p>
@endforeach
```

При нахождении во вложенном цикле, вы можете получить доступ к переменной `$loop` родительского цикла через свойство `parent`:

```blade
@foreach ($users as $user)
    @foreach ($user->posts as $post)
        @if ($loop->parent->first)
            This is the first iteration of the parent loop.
        @endif
    @endforeach
@endforeach
```

Переменная `$loop` также содержит множество других полезных свойств:

|  Свойство  |  Описание  |
|--------------------|--------------------------------------------------------|
|  `$loop->index`  |  Индекс текущей итерации цикла (начинается с 0).  |
|  `$loop->iteration`  |  Текущая итерация цикла (начинается с 1).  |
|  `$loop->remaining`  | Итерации, оставшиеся в цикле.  |
|  `$loop->count`  |  Общее количество элементов в итерируемом массиве.  |
|  `$loop->first`  |  Первая ли это итерация цикла.  |
|  `$loop->last`  |  Последняя ли это итерация цикла.  |
|  `$loop->even`  |  Четная ли это итерация цикла.  |
|  `$loop->odd`  |  Нечетная ли это итерация цикла.  |
|  `$loop->depth`  |  Уровень вложенности текущего цикла.  |
|  `$loop->parent`  |  Переменная родительского цикла во вложенном цикле.  |

<a name="conditional-classes"></a>
### Условные классы

Директива `@class` условно компилирует строку класса CSS. Директива принимает массив классов, где ключ массива содержит класс или классы, которые вы хотите добавить, а значение является логическим выражением. Если элемент массива имеет числовой ключ, он всегда будет включен в отображаемый список классов:

```blade
@php
    $isActive = false;
    $hasError = true;
@endphp

<span @class([
    'p-4',
    'font-bold' => $isActive,
    'text-gray-500' => ! $isActive,
    'bg-red' => $hasError,
])></span>

<span class="p-4 text-gray-500 bg-red"></span>
```

<a name="additional-attributes"></a>
### Дополнительные атрибуты

Для удобства вы можете использовать директиву `@checked`, чтобы указать, должен ли быть «отмечен» HTML-флажок. Эта директива выведет `checked`, если переданное условие является истинным:

```blade
<input type="checkbox"
        name="active"
        value="active"
        @checked(old('active', $user->active)) />
```

Аналогично, директива `@selected` может использоваться для указания, следует ли «выбрать» указанный элемент выпадающего списка:

```blade
<select name="version">
    @foreach ($product->versions as $version)
        <option value="{{ $version }}" @selected(old('version') == $version)>
            {{ $version }}
        </option>
    @endforeach
</select>
```

Аналогично, директива `@disabled` может использоваться для указания, следует ли «заблокировать» указанный элемент:

```blade
<button type="submit" @disabled($errors->isNotEmpty())>Submit</button>
```

Более того, директива `@readonly` может использоваться для указания, должен ли указанный элемент быть «только для чтения»:

```blade
<input type="email"
        name="email"
        value="email@laravel.com"
        @readonly($user->isNotAdmin()) />
```

Кроме того, директива `@required` может использоваться для указания, должен ли указанный элемент быть «обязательным»:

```blade
<input type="text"
        name="title"
        value="title"
        @required($user->isAdmin()) />
```

<a name="including-subviews"></a>
### Подключение дочерних шаблонов

> **Примечание**\
> Хотя вы можете использовать директиву `@include`, [компоненты](#components) Blade содержат аналогичный функционал и предлагают несколько преимуществ по сравнению с директивой `@include`, например привязку данных и атрибутов.

Директива `@include` Blade позволяет вам включать шаблоны из другого шаблона. Все переменные, доступные для родительского шаблона, будут доступны для включенного шаблона:

```blade
<div>
    @include('shared.errors')

    <form>
        <!-- Form Contents -->
    </form>
</div>
```

Включенный шаблон унаследует все данные, доступные в родительском шаблоне, но вы также можете передать массив дополнительных данных, которые должны быть доступны для включенного шаблона:

```blade
@include('view.name', ['status' => 'complete'])
```

Если вы попытаетесь включить несуществующий шаблон, Laravel выдаст ошибку. Если вы хотите включить шаблон, который может присутствовать или отсутствовать, вам следует использовать директиву `@includeIf`:

```blade
@includeIf('view.name', ['status' => 'complete'])
```

Если вы хотите включить шаблон в зависимости от результата логического выражения, возвращающего либо `true`, либо `false`, то используйте директивы `@includeWhen` и `@includeUnless`:

```blade
@includeWhen($boolean, 'view.name', ['status' => 'complete'])

@includeUnless($boolean, 'view.name', ['status' => 'complete'])
```

Чтобы включить первый существующий шаблон из переданного массива шаблонов, вы можете использовать директиву `includeFirst`:

```blade
@includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])
```

> **Предупреждение**\
> Вам следует избегать использования в ваших шаблонах Blade констант `__DIR__` и `__FILE__`, поскольку они будут ссылаться на расположение кешированного, скомпилированного шаблона.

<a name="rendering-views-for-collections"></a>
#### Отрисовка шаблонов с коллекциями

Вы можете cкомбинировать циклы и подключение шаблона в одну строку с помощью директивы Blade `@each`:

```blade
@each('view.name', $jobs, 'job')
```

Первый аргумент директивы `@each` – это шаблон, отображаемый для каждого элемента в массиве или коллекции. Второй аргумент – это массив или коллекция, которую вы хотите перебрать, а третий аргумент – это имя переменной, которая будет присвоена текущей итерации в шаблоне. Так, например, если вы выполняете итерацию по массиву `jobs`, обычно вам нужно обращаться к каждому элементу как к переменной `job` в шаблоне. Ключ массива для текущей итерации будет доступен как переменная `key` в шаблоне.

Вы можете передать четвертый аргумент директиве `@each`. Этот аргумент определяет шаблон, который будет отображаться, если переданный массив пуст.

```blade
@each('view.name', $jobs, 'job', 'view.empty')
```

> **Предупреждение**\
> Шаблоны, отображаемые с помощью `@each`, не наследуют переменные родительского шаблона. Если дочернему шаблону требуются эти переменные, вам следует использовать вместо них директивы `@foreach` и `@include`.

<a name="the-once-directive"></a>
### Директива `@once`

Директива `@once` позволяет вам определить часть шаблона, которая будет проанализирована только один раз за цикл визуализации. Это может быть полезно для вставки переданного фрагмента JavaScript в подвал страницы с помощью [стеков](#stacks). Например, если вы отображаете переданный [компонент](#components) в цикле, то бывает необходимо разместить JavaScript в подвале при визуализации компонента только единожды:

```blade
@once
    @push('scripts')
        <script>
            // Ваш JavaScript...
        </script>
    @endpush
@endonce
```

Поскольку как директива `@once` часто используется в сочетании с директивами `@push` или `@prepend`, то для удобства доступны директивы `@pushOnce` и `@prependOnce`:

```blade
@pushOnce('scripts')
    <script>
        // Ваш JavaScript...
    </script>
@endPushOnce
```

<a name="raw-php"></a>
### Необработанный PHP

В крайних ситуациях можно встроить PHP-код в ваши шаблоны. Вы можете использовать директиву `@php` Blade для размещения блока простого PHP в вашем шаблоне:

```blade
@php
    $counter = 1;
@endphp
```

Если вам нужно написать только одно выражение PHP, то вы можете включить его в директиву `@php`:

```blade
@php($counter = 1)
```

<a name="comments"></a>
### Комментарии

Blade также позволяет вам определять комментарии в ваших шаблонах. Однако, в отличие от комментариев HTML, комментарии Blade не будут включены в результирующий HTML, возвращаемый вашим приложением:

```blade
{{-- Этот комментарий не будет присутствовать в отрисованном HTML --}}
```

<a name="components"></a>
## Компоненты

Компоненты и слоты предоставляют те же преимущества, что и секции, макеты и включение шаблона из другого шаблона; однако, некоторым может быть легче понять мысленную модель компонентов и слотов. Есть два подхода к написанию компонентов: компоненты на основе классов и анонимные компоненты.

Чтобы создать компонент на основе класса, вы можете использовать команду `make:component` [Artisan](artisan.md). Чтобы проиллюстрировать, как использовать компоненты, мы создадим простой компонент `Alert`. Команда `make:component` поместит компонент в каталог `app/View/Components`:

```shell
php artisan make:component Alert
```

Команда `make: component` также создаст шаблон для компонента. Шаблон будет помещен в каталог `resources/views/components`. При написании компонентов для вашего собственного приложения компоненты автоматически обнаруживаются в каталогах `app/View/Components` и `resources/views/components`, поэтому дополнительная регистрация компонентов обычно не требуется.

Вы также можете создавать компоненты в подкаталогах:

```shell
php artisan make:component Forms/Input
```

Приведенная выше команда создаст компонент `Input` в каталоге `app/View/Components/Forms`, а шаблон будет помещен в каталог `resources/views/components/forms`.

Если вы хотите создать анонимный компонент (компонент только с шаблоном Blade и без класса), то вы можете использовать флаг `--view` при вызове команды `make:component`:

```shell
php artisan make:component forms.input --view
```

Приведенная выше команда создаст файл Blade в `resources/views/components/forms/input.blade.php`, который можно использовать как компонент: `<x-forms.input />`.

<a name="manually-registering-package-components"></a>
#### Самостоятельная регистрация компонентов пакета

При написании компонентов для вашего собственного приложения компоненты автоматически обнаруживаются в каталогах `app/View/Components` и `resources/views/components`.

Однако, если вы создаете пакет, который использует компоненты Blade, вам необходимо вручную зарегистрировать класс компонента и его псевдоним HTML-тега. Вы должны зарегистрировать свои компоненты в методе `boot` поставщика служб вашего пакета:

    use Illuminate\Support\Facades\Blade;

    /**
     * Загрузка служб вашего пакета.
     */
    public function boot()
    {
        Blade::component('package-alert', Alert::class);
    }

После того, как ваш компонент был зарегистрирован, он может быть отображен с использованием псевдонима тега:

```blade
<x-package-alert/>
```

Как вариант, вы можете использовать метод `componentNamespace` для автоматической загрузки классов компонентов по соглашению. Например, пакет `Nightshade` может иметь компоненты `Calendar` и `ColorPicker`, которые находятся в пространстве имен `Package\Views\Components`:

    use Illuminate\Support\Facades\Blade;

    /**
     * Загрузка служб вашего пакета.
     *
     * @return void
     */
    public function boot()
    {
        Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade');
    }

Это позволит использовать компоненты пакета в пространстве имен их поставщиков, используя синтаксис `x-package-name::`:

```blade
<x-nightshade::calendar />
<x-nightshade::color-picker />
```

Blade автоматически обнаружит класс, связанный с этим компонентом, используя «верблюжий регистр» имени компонента. Подкаталоги также поддерживаются с использованием «точечной» нотации.

<a name="rendering-components"></a>
### Отрисовка компонентов

Для отображения компонента вы можете использовать тег компонента Blade в одном из ваших шаблонов Blade. Теги компонентов Blade начинаются со строки `x-`, за которой следует имя в «шашлычном регистре» класса компонента:

```blade
<x-alert/>

<x-user-profile/>
```

Если класс компонента имеет вложенность в каталоге `app/View/Components`, то вы можете использовать символ `.` для обозначения вложенности каталогов. Например, если мы предполагаем, что компонент находится в `app/View/Components/Inputs/Button.php`, то мы можем отобразить его так:

```blade
<x-inputs.button/>
```

<a name="passing-data-to-components"></a>
### Передача данных компонентам

Вы можете передавать данные в компоненты Blade, используя атрибуты HTML. Жестко запрограммированные примитивные значения могут быть переданы компоненту с помощью простых строк атрибутов HTML. Выражения и переменные PHP следует передавать компоненту через атрибуты, которые используют символ `:` в качестве префикса:

```blade
<x-alert type="error" :message="$message"/>
```

Вы должны определить все атрибуты данных компонента в его конструкторе класса. Все общедоступные свойства компонента будут автоматически доступны в шаблоне компонента. Нет необходимости передавать данные в шаблон из метода `render` компонента:

    <?php

    namespace App\View\Components;

    use Illuminate\View\Component;

    class Alert extends Component
    {
        /**
         * Тип предупреждения.
         *
         * @var string
         */
        public $type;

        /**
         * Предупреждающее сообщение.
         *
         * @var string
         */
        public $message;

        /**
         * Создать экземпляр компонента.
         *
         * @param  string  $type
         * @param  string  $message
         * @return void
         */
        public function __construct($type, $message)
        {
            $this->type = $type;
            $this->message = $message;
        }

        /**
         * Получить шаблон / содержимое, представляющее компонент.
         *
         * @return \Illuminate\View\View|\Closure|string
         */
        public function render()
        {
            return view('components.alert');
        }
    }

Когда ваш компонент визуализируется, вы можете отображать содержимое общедоступных переменных вашего компонента, выводя переменные по имени:

```blade
<div class="alert alert-{{ $type }}">
    {{ $message }}
</div>
```

<a name="casing"></a>
#### Именование

Аргументы конструктора компонентов следует указывать с помощью `camelCase`, а при обращении к именам аргументов в ваших атрибутах HTML следует использовать `kebab-case`. Например, учитывая следующий конструктор компонента:

    /**
     * Создать экземпляр компонента.
     *
     * @param  string  $alertType
     * @return void
     */
    public function __construct($alertType)
    {
        $this->alertType = $alertType;
    }

Аргумент `$alertType` может быть передан компоненту следующим образом:

```blade
<x-alert alert-type="danger" />
```

<a name="short-attribute-syntax"></a>
#### Синтаксис кратких атрибутов

При передаче атрибутов компонентам вы можете использовать синтаксис «кратких атрибутов». Это бывает удобно, поскольку имена атрибутов часто совпадают с именами переменных, которым они соответствуют:

```blade
{{-- Синтаксис кратких атрибутов ... --}}
<x-profile :$userId :$name />

{{-- Эквивалентно ... --}}
<x-profile :user-id="$userId" :name="$name" />
```

<a name="escaping-attribute-rendering"></a>
#### Экранирование атрибутов от синтаксического анализа

Поскольку некоторые фреймворки JavaScript, такие как Alpine.js, также используют атрибуты с префиксом двоеточия, вы можете использовать префикс с двойным двоеточием (`::`), чтобы сообщить Blade, что атрибут не является выражением PHP. Например, учитывая следующий компонент:

```blade
<x-button ::class="{ danger: isDeleting }">
    Submit
</x-button>
```

Blade отобразит следующий HTML-код:

```blade
<button :class="{ danger: isDeleting }">
    Submit
</button>
```

<a name="component-methods"></a>
#### Методы компонента

В дополнение к общедоступным переменным, доступным для вашего шаблона компонента, могут быть вызваны любые общедоступные методы компонента. Например, представьте компонент, у которого есть метод `isSelected`:

    /**
     * Определить, является ли переданная опция выбранной.
     *
     * @param  string  $option
     * @return bool
     */
    public function isSelected($option)
    {
        return $option === $this->selected;
    }

Вы можете выполнить этот метод из своего шаблона компонента, вызвав переменную, соответствующую имени метода:

```blade
<option {{ $isSelected($value) ? 'selected' : '' }} value="{{ $value }}">
    {{ $label }}
</option>
```

<a name="using-attributes-slots-within-component-class"></a>
#### Доступ к атрибутам и слотам в классах компонентов

Компоненты Blade также позволяют получить доступ к имени компонента, атрибутам и слоту внутри метода `render` класса. Однако, чтобы получить доступ к этим данным, вы должны вернуть замыкание из метода `render` вашего компонента. Замыкание получит массив `$data` в качестве единственного аргумента. Этот массив будет содержать несколько элементов, предоставляющих информацию о компоненте:

    /**
     * Получить шаблон / содержимое, представляющее компонент.
     *
     * @return \Illuminate\View\View|\Closure|string
     */
    public function render()
    {
        return function (array $data) {
            // $data['componentName'];
            // $data['attributes'];
            // $data['slot'];

            return '<div>Components content</div>';
        };
    }

`componentName` эквивалентно имени, используемому в HTML-теге после префикса `x-`. Таким образом, `componentName` компонента `<x-alert />` будет `alert`. Элемент `attributes` будет содержать все атрибуты, которые присутствовали в HTML-теге. Элемент `slot` – это экземпляр `Illuminate\Support\HtmlString` с содержимым слота компонента.

Замыкание должно возвращать строку. Если возвращенная строка соответствует существующему шаблону, то этот шаблон будет отрисован; в противном случае возвращенная строка будет оцениваться как встроенный шаблон Blade.

<a name="additional-dependencies"></a>
#### Дополнительные зависимости

Если вашему компоненту требуются зависимости из [контейнера служб](container.md) Laravel, то вы можете указать их перед любыми атрибутами данных компонента, и они будут автоматически внедрены контейнером:

```php
use App\Services\AlertCreator;

/**
 * Создать экземпляр компонента.
 *
 * @param  \App\Services\AlertCreator  $creator
 * @param  string  $type
 * @param  string  $message
 * @return void
 */
public function __construct(AlertCreator $creator, $type, $message)
{
    $this->creator = $creator;
    $this->type = $type;
    $this->message = $message;
}
```

<a name="hiding-attributes-and-methods"></a>
#### Скрытие атрибутов / методов

Если вы хотите, чтобы некоторые публичные методы или свойства не использовались как переменные в шаблоне компонента, вы можете добавить их в свойство массива `$except` в вашем компоненте:

    <?php

    namespace App\View\Components;

    use Illuminate\View\Component;

    class Alert extends Component
    {
        /**
         * Тип предупреждения.
         *
         * @var string
         */
        public $type;

        /**
         * Свойства / методы, которые не должны использоваться в шаблоне компонента.
         *
         * @var array
         */
        protected $except = ['type'];
    }

<a name="component-attributes"></a>
### Атрибуты компонента

Мы уже рассмотрели, как передавать атрибуты данных в компонент; иногда требуется указать дополнительные атрибуты HTML, такие как `class`, которые не являются частью данных, необходимых для функционирования компонента. Как правило, вы хотите передать эти дополнительные атрибуты корневому элементу шаблона компонента. Например, представьте, что мы хотим отобразить компонент `alert` следующим образом:

```blade
<x-alert type="error" :message="$message" class="mt-4"/>
```

Все атрибуты, которые не являются частью конструктора компонента, будут автоматически добавлены в «коллекцию атрибутов» компонента. Эта коллекция атрибутов автоматически становится доступной для компонента через переменную `$attributes`. Все атрибуты могут отображаться в компоненте путем вывода этой переменной:

```blade
<div {{ $attributes }}>
    <!-- Содержимое компонента -->
</div>
```

> **Предупреждение**\
> Использование таких директив, как `@env` в тегах компонентов в настоящее время не поддерживается. Например, `<x-alert :live="@env('production')"/>` не будет компилироваться.

<a name="default-merged-attributes"></a>
#### Атрибуты по умолчанию и слияние атрибутов

Иногда требуется указать значения по умолчанию для атрибутов или добавить дополнительные значения в некоторые атрибуты компонента. Для этого вы можете использовать метод `merge` коллекции атрибутов. Этот метод особенно полезен для определения набора CSS-классов по умолчанию, которые всегда должны применяться к компоненту:

```blade
<div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>
    {{ $message }}
</div>
```

Если предположить,

```blade
<x-alert type="error" :message="$message" class="mb-4"/>
```

Окончательный обработанный HTML-код компонента будет выглядеть следующим образом:

```blade
<div class="alert alert-error mb-4">
    <!-- Содержимое переменной $message -->
</div>
```

<a name="conditionally-merge-classes"></a>
#### Условное слияние классов

По желанию можно объединить классы, если указанное условие истинно. Вы можете сделать это с помощью метода `class`, который принимает массив классов, где ключ массива содержит класс или классы, которые вы хотите добавить, а значение является логическим выражением. Если элемент массива имеет числовой ключ, то он всегда будет добавлен в конечный список классов:

```blade
<div {{ $attributes->class(['p-4', 'bg-red' => $hasError]) }}>
    {{ $message }}
</div>
```

Если вам нужно объединить другие атрибуты в свой компонент, вы можете связать метод `merge` с методом `class`:

```blade
<button {{ $attributes->class(['p-4'])->merge(['type' => 'button']) }}>
    {{ $slot }}
</button>
```

> **Примечание**\
> Если вам нужно условно скомпилировать классы для других элементов HTML, которые не должны получать объединенные атрибуты, вы можете использовать [директиву `@class`](#conditional-classes).

<a name="non-class-attribute-merging"></a>
#### Слияние неклассовых атрибутов

При слиянии атрибутов, которые не являются атрибутами класса, значения, предоставленные методу `merge`, будут считаться значениями атрибута по умолчанию. Однако, в отличие от атрибута `class`, эти атрибуты не будут объединены с указанными значениями атрибутов. Вместо этого они будут перезаписаны. Например, реализация компонента `button` может выглядеть следующим образом:

```blade
<button {{ $attributes->merge(['type' => 'button']) }}>
    {{ $slot }}
</button>
```

Чтобы отобразить компонент кнопки с настраиваемым `type`, его можно указать при использовании компонента. Если тип не указан, будет использоваться тип `button`, определенный по умолчанию:

```blade
<x-button type="submit">
    Submit
</x-button>
```

Обработанный HTML-код компонента `button` в этом примере будет:

```blade
<button type="submit">
    Submit
</button>
```

Если вы хотите, чтобы атрибут, отличный от `class`, имел значение по умолчанию и указанное значение, объединенные вместе, вы можете использовать метод `prepends`. В этом примере атрибут `data-controller` всегда будет начинаться с `profile-controller`, а любые дополнительные указанные значения `data-controller` будут помещены после этого значения по умолчанию:

```blade
<div {{ $attributes->merge(['data-controller' => $attributes->prepends('profile-controller')]) }}>
    {{ $slot }}
</div>
```

<a name="filtering-attributes"></a>
#### Получение и фильтрация атрибутов

Вы можете фильтровать атрибуты, используя метод `filter`. Этот метод принимает замыкание, которое должно возвращать `true`, если вы хотите сохранить атрибут в коллекции атрибутов:

```blade
{{ $attributes->filter(fn ($value, $key) => $key == 'foo') }}
```

Для удобства вы можете использовать метод `whereStartsWith` для получения всех атрибутов, ключи которых начинаются с указанной строки:

```blade
{{ $attributes->whereStartsWith('wire:model') }}
```

И наоборот, метод `whereDoesntStartWith` может использоваться для исключения всех атрибутов, ключи которых начинаются с указанной строки:

```blade
{{ $attributes->whereDoesntStartWith('wire:model') }}
```

Используя метод `first`, вы можете отобразить первый атрибут в указанной коллекции атрибутов:

```blade
{{ $attributes->whereStartsWith('wire:model')->first() }}
```

Если вы хотите проверить, присутствует ли атрибут в компоненте, вы можете использовать метод `has`. Этот метод принимает имя атрибута в качестве единственного аргумента и возвращает логическое значение, указывающее, присутствует ли атрибут:

```blade
@if ($attributes->has('class'))
    <div>Class attribute is present</div>
@endif
```

Вы можете получить значение конкретного атрибута, используя метод `get`:

```blade
{{ $attributes->get('class') }}
```

<a name="reserved-keywords"></a>
### Зарезервированные ключевые слова

По умолчанию некоторые ключевые слова зарезервированы для внутреннего использования Blade при визуализации компонентов. Следующие ключевые слова не могут быть определены как публичные свойства или имена методов в ваших компонентах:

<!-- <div class="content-list" markdown="1"> -->

- `data`
- `render`
- `resolveView`
- `shouldRender`
- `view`
- `withAttributes`
- `withName`

<!-- </div> -->

<a name="slots"></a>
### Слоты

Вам часто потребуется передавать дополнительный контент вашему компоненту через «слоты». Слоты компонентов отображаются путем вывода переменной `$slot`. Чтобы изучить эту концепцию, представим, что компонент `alert` имеет следующую разметку:

```blade
<!-- /resources/views/components/alert.blade.php -->

<div class="alert alert-danger">
    {{ $slot }}
</div>
```

Мы можем передавать контент в `slot`, вставив контент в компонент:

```blade
<x-alert>
    <strong>Whoops!</strong> Something went wrong!
</x-alert>
```

Иногда внутри компонента требуется отрисовать несколько разных слотов в разных местах. Давайте модифицируем наш компонент оповещения, чтобы учесть вставку слота `title`:

```blade
<!-- /resources/views/components/alert.blade.php -->

<span class="alert-title">{{ $title }}</span>

<div class="alert alert-danger">
    {{ $slot }}
</div>
```

Вы можете определить содержимое именованнго слота с помощью тега `x-slot`. Любой контент, не указанный в явном теге `x-slot`, будет передан компоненту в переменной `$slot`:

```xml
<x-alert>
    <x-slot:title>
        Server Error
    </x-slot>

    <strong>Whoops!</strong> Something went wrong!
</x-alert>
```

<a name="scoped-slots"></a>
#### Слоты с ограниченной областью видимости

Если вы использовали фреймворк JavaScript, такой как Vue, то вы, возможно, знакомы со «слотами с ограниченной областью видимости», которые позволяют получать доступ к данным или методам из компонента в вашем слоте. Вы можете добиться аналогичного поведения в Laravel, определив общедоступные методы или свойства в вашем компоненте и получив доступ к компоненту в вашем слоте через переменную `$component`. В этом примере мы предположим, что компонент `x-alert` имеет общедоступный метод `formatAlert`, определенный в его классе компонента:

```blade
<x-alert>
    <x-slot:title>
        {{ $component->formatAlert('Server Error') }}
    </x-slot>

    <strong>Whoops!</strong> Something went wrong!
</x-alert>
```

<a name="slot-attributes"></a>
#### Атрибуты слота

Подобно компонентам Blade, вы можете назначить дополнительные [атрибуты](#component-attributes) для слотов, такие как имена CSS-классов:

```xml
<x-card class="shadow-sm">
    <x-slot:heading class="font-bold">
        Heading
    </x-slot>

    Content

    <x-slot:footer class="text-sm">
        Footer
    </x-slot>
</x-card>
```

Для взаимодействия с атрибутами слота вы можете получить доступ к свойству `attributes` переменной слота. Для получения дополнительной информации о том, как взаимодействовать с атрибутами, обратитесь к документации по [атрибутам компонента](#component-attributes):

```blade
@props([
    'heading',
    'footer',
])

<div {{ $attributes->class(['border']) }}>
    <h1 {{ $heading->attributes->class(['text-lg']) }}>
        {{ $heading }}
    </h1>

    {{ $slot }}

    <footer {{ $footer->attributes->class(['text-gray-700']) }}>
        {{ $footer }}
    </footer>
</div>
```

<a name="inline-component-views"></a>
### Встроенные шаблоны компонентов

Для очень маленьких компонентов может показаться обременительным управлять как классом компонента, так и шаблоном компонента. По этой причине вы можете вернуть разметку компонента прямо из метода `render`:

    /**
     * Получить шаблон / содержимое, представляющее компонент.
     *
     * @return \Illuminate\View\View|\Closure|string
     */
    public function render()
    {
        return <<<'blade'
            <div class="alert alert-danger">
                {{ $slot }}
            </div>
        blade;
    }

<a name="generating-inline-view-components"></a>
#### Генерация компонентов со встроенными шаблонами

Чтобы создать компонент, который использует встроенный шаблон, вы можете использовать параметр `--inline` при выполнении команды `make:component`:

```shell
php artisan make:component Alert --inline
```

<a name="dynamic-components"></a>
### Динамические компоненты

Иногда требуется визуализировать компонент, но вы не знаете, какой компонент следует визуализировать до времени выполнения. В этой ситуации вы можете использовать встроенный в Laravel компонент `dynamic-component` для отображения компонента на основе значения или переменной, полученной во время выполнения запроса:

```blade
<x-dynamic-component :component="$componentName" class="mt-4" />
```

<a name="manually-registering-components"></a>
### Самостоятельная регистрация компонентов

> **Предупреждение**\
> Следующая документация по самостоятельной регистрации компонентов в первую очередь полезна тем, кто пишет пакеты Laravel, которые включают компоненты. Если вы не пишете пакет, эта часть документации компонента может быть вам не нужна.

При написании компонентов для вашего собственного приложения компоненты автоматически обнаруживаются в каталогах `app/View/Components` и `resources/views/components`.

Однако, если вы создаете пакет, который использует компоненты Blade или размещаете компоненты в других каталогах, вам необходимо самостоятельно зарегистрировать класс компонента и его псевдоним HTML-тега, чтобы Laravel знал, где найти компонент. Вы должны зарегистрировать свои компоненты в методе `boot` поставщика служб вашего пакета:

    use Illuminate\Support\Facades\Blade;
    use VendorPackage\View\Components\AlertComponent;

    /**
     * Загрузка служб вашего пакета.
     *
     * @return void
     */
    public function boot()
    {
        Blade::component('package-alert', AlertComponent::class);
    }

После того, как ваш компонент был зарегистрирован, он может быть отображен с использованием псевдонима тега:

```blade
<x-package-alert/>
```

#### Автозагрузка компонентов пакета

Как вариант, вы можете использовать метод `componentNamespace` для автоматической загрузки классов компонентов по соглашению. Например, пакет `Nightshade` может иметь компоненты `Calendar` и `ColorPicker`, которые находятся в пространстве имен `Package\Views\Components`:

    use Illuminate\Support\Facades\Blade;

    /**
     * Загрузка служб вашего пакета.
     *
     * @return void
     */
    public function boot()
    {
        Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade');
    }

Это позволит использовать компоненты пакета в пространстве имен их поставщиков, используя синтаксис `x-package-name::`:

```blade
<x-nightshade::calendar />
<x-nightshade::color-picker />
```

Blade автоматически обнаружит класс, связанный с этим компонентом, используя «регистр паскаля» имени компонента. Также поддерживаются подкаталоги с использованием «точечной» нотации.

<a name="anonymous-components"></a>
## Анонимные компоненты

Подобно встроенным компонентам, анонимные компоненты предоставляют механизм для управления компонентом через один файл. Однако анонимные компоненты используют один файл шаблона, но не имеют связанного с компонентом класса. Чтобы определить анонимный компонент, вам нужно только разместить шаблон Blade в вашем каталоге `resources/views/components`. Например, если вы определили компонент в `resources/views/components/alert.blade.php`, вы можете просто отобразить его так:

```blade
<x-alert/>
```

Вы можете использовать символ `.`, чтобы указать, вложен ли компонент в каталоге `components`. Например, если компонент определен в `resources/views/components/inputs/button.blade.php`, вы можете отобразить его так:

```blade
<x-inputs.button/>
```

<a name="anonymous-index-components"></a>
### Анонимные составные компоненты

Если компонент состоит из множества шаблонов Blade, то вы можете сгруппировать шаблоны данного компонента в одном каталоге. Например, представьте себе компонент «аккордеон» со следующей структурой каталогов:

```none
/resources/views/components/accordion.blade.php
/resources/views/components/accordion/item.blade.php
```

Эта структура каталогов позволяет отображать компонент аккордеона и его элементы следующим образом:

```blade
<x-accordion>
    <x-accordion.item>
        ...
    </x-accordion.item>
</x-accordion>
```

Однако для того, чтобы отобразить данный компонент через `x-accordion`, мы были вынуждены поместить «индексный» шаблон компонента в каталог `resources/views/components` вместо того, чтобы вкладывать его вместе с другими связанными шаблонами в каталог `accordion`.

К счастью, Blade позволяет вам разместить файл `index.blade.php` в каталоге шаблонов компонента. Когда для компонента существует шаблон `index.blade.php`, он будет отображаться как «корневой» узел компонента. Итак, мы можем продолжать использовать тот же синтаксис Blade, что и в примере выше, но мы изменим структуру каталогов следующим образом:

```none
/resources/views/components/accordion/index.blade.php
/resources/views/components/accordion/item.blade.php
```

<a name="data-properties-attributes"></a>
### Свойства / атрибуты данных

Поскольку анонимные компоненты не имеют ассоциированного класса, вы можете задаться вопросом, как можно различить, какие данные должны быть переданы компоненту как переменные, а какие атрибуты должны быть помещены в [коллекцию атрибутов](#component-attributes) компонента.

Вы можете указать, какие атрибуты следует рассматривать как переменные данных, используя директиву `@props` в верхней части шаблона Blade вашего компонента. Все остальные атрибуты компонента будут доступны через коллекцию атрибутов компонента. Если вы хотите присвоить переменной данных значение по умолчанию, вы можете указать имя переменной в качестве ключа массива и значение по умолчанию в качестве значения массива:

```blade
<!-- /resources/views/components/alert.blade.php -->

@props(['type' => 'info', 'message'])

<div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>
    {{ $message }}
</div>
```

Учитывая приведенное выше определение компонента, мы можем отобразить компонент следующим образом:

```blade
<x-alert type="error" :message="$message" class="mb-4"/>
```

<a name="accessing-parent-data"></a>
### Доступ к данным родительского компонента

Иногда внутри дочернего компонента требуется доступ к данным родительского компонента. В этих случаях вы можете использовать директиву `@aware`. Например, представьте, что мы создаем сложный компонент меню, состоящий из родительского `<x-menu>` и дочернего `<x-menu.item>`:

```blade
<x-menu color="purple">
    <x-menu.item>...</x-menu.item>
    <x-menu.item>...</x-menu.item>
</x-menu>
```

Компонент `<x-menu>` может иметь следующую реализацию:

```blade
<!-- /resources/views/components/menu/index.blade.php -->

@props(['color' => 'gray'])

<ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}>
    {{ $slot }}
</ul>
```

Поскольку свойство `color` было передано только родительскому элементу `<x-menu>`, оно не будет доступно внутри `<x-menu.item>`. Однако, если мы воспользуемся директивой `@aware`, то мы можем сделать свойство доступным и внутри `<x-menu.item>`:

```blade
<!-- /resources/views/components/menu/item.blade.php -->

@aware(['color' => 'gray'])

<li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}>
    {{ $slot }}
</li>
```

> **Предупреждение**\
> Директива `@aware` не может получить доступ к родительским данным, если они не переданы родительскому компоненту явным образом через атрибуты HTML. Значения по умолчанию `@props`, которые не переданы явно родительскому компоненту, не могут быть доступны директиве `@aware`.

<a name="anonymous-component-namespaces"></a>
### Пути анонимных компонентов

Как обсуждалось ранее, анонимные компоненты обычно определяются путем размещения шаблона Blade в вашем каталоге `resources/views/components`. Однако иногда требуется зарегистрировать другие пути анонимных компонентов в Laravel в дополнение к пути по умолчанию.

Метод `anonymousComponentPath` принимает «путь» к местоположению анонимного компонента в качестве первого аргумента и необязательное «пространство имен», в котором должны быть размещены компоненты, в качестве второго аргумента. Как правило, вызов этого метода осуществляется в методе `boot` одного из [поставщиков служб](providers.md) вашего приложения:

    /**
     * Загрузка любых служб приложения.
     *
     * @return void
     */
    public function boot()
    {
        Blade::anonymousComponentPath(__DIR__.'/../components');
    }

Когда пути к компонентам зарегистрированы без указанного префикса, как в приведенном выше примере, тогда они могут быть выведены в компонентах Blade также без соответствующего префикса. Например, если в указанном выше пути существует компонент `panel.blade.php`, то он может отображаться следующим образом:

```blade
<x-panel />
```

Префикс «пространства имен» может быть указан в качестве второго аргумента метода `anonymousComponentPath`:

    Blade::anonymousComponentPath(__DIR__.'/../components', 'dashboard');

Когда префикс указан, тогда компоненты в этом «пространстве имен» могут быть выведены путем добавления префикса к пространству имен компонента к имени компонента при отображении компонента:

```blade
<x-dashboard::panel />
```

<a name="building-layouts"></a>
## Создание макетов

<a name="layouts-using-components"></a>
### Макеты с использованием компонентов

Большинство веб-приложений поддерживают одинаковый общий макет на разных страницах. Было бы невероятно громоздко и сложно поддерживать наше приложение, если бы нам приходилось повторять весь HTML-макет в каждом создаваемом экране. К счастью, этот макет удобно определить как один [компонент Blade](#components), а затем использовать его во всем приложении.

<a name="defining-the-layout-component"></a>
#### Определение компонента макета

Например, представьте, что мы создаем приложение со списком задач. Мы могли бы определить компонент `layout`, который выглядит следующим образом:

```blade
<!-- resources/views/components/layout.blade.php -->

<html>
<head>
    <title>{{ $title ?? 'Todo Manager' }}</title>
</head>
<body>
    <h1>Todos</h1>
    <hr/>
    {{ $slot }}
</body>
</html>
```

<a name="applying-the-layout-component"></a>
#### Использование компонента макета

Как только компонент `layout` определен, мы можем создать шаблон Blade, который будет использовать этот компонент. В этом примере мы определим простой шаблон, который отображает наш список задач:

```blade
<!-- resources/views/tasks.blade.php -->

<x-layout>
@foreach ($tasks as $task)
    {{ $task }}
@endforeach
</x-layout>
```

Помните, что содержимое, внедренное в компонент, по умолчанию будет передано переменной `$slot` компонента `layout`. Как вы могли заметить, наш `layout` также учитывает слот `$title`, если он предусмотрен; в противном случае отображается заголовок по умолчанию. Мы можем добавить другой заголовок из нашего шаблона списка задач, используя стандартный синтаксис слотов, описанный в [документации по компонентам](#components):

```blade
<!-- resources/views/tasks.blade.php -->

<x-layout>
<x-slot:title>
    Custom Title
</x-slot>

@foreach ($tasks as $task)
    {{ $task }}
@endforeach
</x-layout>
```

Теперь, когда мы определили наш макет и шаблоны списка задач, нам просто нужно вернуть представление `task` из маршрута:

use App\Models\Task;

Route::get('/tasks', function () {
    return view('tasks', ['tasks' => Task::all()]);
});

<a name="layouts-using-template-inheritance"></a>
### Макеты с использованием наследования шаблонов

<a name="defining-a-layout"></a>
#### Определение макета

Макеты также могут быть созданы с помощью «наследования шаблонов». Это был основной способ создания приложений до появления [компонентов](#components).

Для начала рассмотрим простой пример. Сначала мы изучим макет страницы. Поскольку большинство веб-приложений поддерживают одинаковый общий макет на разных страницах, удобно определить этот макет как единый шаблон Blade:

```blade
<!-- resources/views/layouts/app.blade.php -->

<html>
<head>
    <title>App Name - @yield('title')</title>
</head>
<body>
    @section('sidebar')
        This is the master sidebar.
    @show

    <div class="container">
        @yield('content')
    </div>
</body>
</html>
```

Как видите, этот файл содержит типичную разметку HTML. Однако, обратите внимание на директивы `@section` и `@yield`. Директива `@ section`, как следует из названия, определяет секцию содержимого, тогда как директива `@yield` используется для отображения содержимого секции, предоставленного дочерним шаблоном.

Теперь, когда мы определили макет для нашего приложения, давайте определим дочернюю страницу, которая наследует макет.

<a name="extending-a-layout"></a>
#### Расширение макета

При определении дочернего шаблона используйте директиву Blade `@extends`, чтобы указать, какой макет дочерний шаблон должен «наследовать». Шаблоны, расширяющие макет Blade, могут добавлять содержимое в секции макета с помощью директив `@section`. Помните, как видно из приведенного выше примера, содержимое этих секций будет отображаться в макете с помощью `@yield`:

```blade
<!-- resources/views/child.blade.php -->

@extends('layouts.app')

@section('title', 'Page Title')

@section('sidebar')
@@parent

<p>This is appended to the master sidebar.</p>
@endsection

@section('content')
<p>This is my body content.</p>
@endsection
```

В этом примере секция `sidebar` использует директиву `@@parent` для добавления (а не перезаписи) содержимого к боковой панели макета. Директива `@@parent` будет заменена содержимым макета при визуализации представления.

> **Примечание**\
> В отличие от предыдущего примера, нынешняя секция `sidebar` заканчивается `@endsection` вместо `@show`. Директива `@endsection` будет только определять секцию, в то время как `@show` будет определять и **немедленно дополнять** секцию.

Директива `@yield` также принимает значение по умолчанию в качестве второго параметра. Это значение будет отображено, если дополняемый раздел не определен:

```blade
@yield('content', 'Default content')
```

<a name="forms"></a>
## Формы

<a name="csrf-field"></a>
### Поле CSRF

Каждый раз, когда вы определяете HTML-форму в своем приложении, вы должны включать в форму скрытое поле токена CSRF, чтобы посредник [защиты от CSRF](csrf.md) мог провалидировать запрос. Вы можете использовать директиву `@csrf` Blade для генерации поля токена:

```blade
<form method="POST" action="/profile">
@csrf

...
</form>
```

<a name="method-field"></a>
### Поле Method

Поскольку HTML-формы не могут выполнять запросы `PUT`, `PATCH` или `DELETE`, вам нужно будет добавить скрытое поле `_method`, чтобы подменить эти HTTP-методы. Директива `@method` Blade поможет создать для вас такое поле:

```blade
<form action="/foo/bar" method="POST">
@method('PUT')

...
</form>
```

<a name="validation-errors"></a>
### Ошибки валидации

Директива `@error` используется для быстрой проверки наличия [сообщений об ошибках валидации](validation.md#quick-displaying-the-validation-errors) для конкретного атрибута. В директиве `@error` вы можете вывести содержимое переменной `$message` для отображения сообщения об ошибке:

```blade
<!-- /resources/views/post/create.blade.php -->

<label for="title">Post Title</label>

<input id="title"
    type="text"
    class="@error('title') is-invalid @enderror">

@error('title')
<div class="alert alert-danger">{{ $message }}</div>
@enderror
```

Поскольку директива `@error` компилируется в конструкцию `if`, то вы можете использовать директиву `@else` для отображения содержимого в случае отсутствия ошибки валидации атрибута:

```blade
<!-- /resources/views/auth.blade.php -->

<label for="email">Email address</label>

<input id="email"
    type="email"
    class="@error('email') is-invalid @else is-valid @enderror">
```

Вы можете передать [имя конкретной коллекции ошибок](validation.md#named-error-bags) в качестве второго параметра директивы `@error` для получения сообщений об ошибках валидации на страницах, содержащих несколько форм:

```blade
<!-- /resources/views/auth.blade.php -->

<label for="email">Email address</label>

<input id="email"
    type="email"
    class="@error('email', 'login') is-invalid @enderror">

@error('email', 'login')
<div class="alert alert-danger">{{ $message }}</div>
@enderror
```

<a name="stacks"></a>
## Стеки

Blade позволяет вам добавлять содержимое к именованным стекам, которые можно отобразить где-нибудь еще в другом шаблоне или макете. Это может быть особенно полезно для указания любых библиотек JavaScript, необходимых для ваших дочерних шаблонов:

```blade
@push('scripts')
    <script src="/example.js"></script>
@endpush
```

Если вы хотите добавить содержимое в `@push`, только при соблюдении условий логического выражения, то вы можете использовать директиву `@pushIf`:

```blade
@pushIf($shouldPush, 'scripts')
    <script src="/example.js"></script>
@endPushIf
```

Вы можете помещать в стек сколько угодно раз. Чтобы отобразить полное содержимое стека, передайте имя стека в директиву `@stack`:

```blade
<head>
    <!-- Head Contents -->

    @stack('scripts')
</head>
```

Если вы хотите добавить содержимое в начало стека, вы должны использовать директиву `@prepend`:

```blade
@push('scripts')
    This will be second...
@endpush

// Later...

@prepend('scripts')
    This will be first...
@endprepend
```

<a name="service-injection"></a>
## Внедрение служб

Директива `@inject` используется для извлечения службы из [контейнера служб](container.md) Laravel. Первый аргумент, переданный в `@inject`, – это имя переменной, в которую будет помещена служба, а второй аргумент – это имя класса или интерфейса службы, которую вы хотите извлечь:

```blade
@inject('metrics', 'App\Services\MetricsService')

<div>
    Monthly Revenue: {{ $metrics->monthlyRevenue() }}.
</div>
```

<a name="rendering-inline-blade-templates"></a>
## Отрисовка встроенных шаблонов Blade

Иногда требуется преобразовать строку шаблона Blade в HTML. Вы можете сделать это, используя метод `render` фасада `Blade`. Метод `render` принимает строку шаблона Blade и необязательный массив данных для шаблона:

```php
use Illuminate\Support\Facades\Blade;

return Blade::render('Hello, {{ $name }}', ['name' => 'Julian Bashir']);
```

Laravel отображает встроенные шаблоны Blade, записывая их в каталог `storage/framework/views`. Если вы хотите, чтобы Laravel удалял эти временные файлы после отрисовки шаблона Blade, то вы можете передать методу именованный аргумент `deleteCachedView`:

```php
return Blade::render(
    'Hello, {{ $name }}',
    ['name' => 'Julian Bashir'],
    deleteCachedView: true
);
```

<a name="rendering-blade-fragments"></a>
## Отрисовка фрагментов Blade

При использовании интерфейсных фреймворков, таких как [Turbo](https://turbo.hotwired.dev/) и [htmx](https://htmx.org/), иногда может потребоваться вернуть только часть шаблона Blade в рамках вашего HTTP-ответа. «Фрагменты» Blade позволяют сделать именно это. Для начала поместите часть вашего шаблона Blade в директивы `@fragment` и `@endfragment`:

```blade
@fragment('user-list')
    <ul>
        @foreach ($users as $user)
            <li>{{ $user->name }}</li>
        @endforeach
    </ul>
@endfragment
```

Затем при отрисовки представления, использующего этот шаблон, вы можете вызвать метод `fragment` для указания того, что только указанный фрагмент должен быть включен в исходящий HTTP-ответ:

```php
return view('dashboard', ['users' => $users])->fragment('user-list');
```

<a name="extending-blade"></a>
## Расширение Blade

Blade позволяет вам определять ваши собственные пользовательские директивы с помощью метода `directive`. Когда компилятор Blade встречает вашу директиву, он вызывает указанное замыкание с выражением, содержащимся в директиве.

В следующем примере создается директива `@datetime($var)`, которая форматирует переданный `$var`, который должен быть экземпляром `DateTime`:

    <?php

    namespace App\Providers;

    use Illuminate\Support\Facades\Blade;
    use Illuminate\Support\ServiceProvider;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Регистрация любых служб приложения.
         *
         * @return void
         */
        public function register()
        {
            //
        }

        /**
         * Загрузка любых служб приложения.
         *
         * @return void
         */
        public function boot()
        {
            Blade::directive('datetime', function ($expression) {
                return "<?php echo ($expression)->format('m/d/Y H:i'); ?>";
            });
        }
    }

Как видите, мы привяжем метод `format` к любому выражению, переданному в директиву. Итак, в этом примере окончательный PHP, сгенерированный этой директивой, будет:

    <?php echo ($var)->format('m/d/Y H:i'); ?>

> **Предупреждение**\
> После обновления логики директивы Blade вам нужно будет удалить все кешированные шаблоны Blade. Кешированные шаблоны Blade могут быть удалены с помощью команды `view:clear` Artisan.

<a name="custom-echo-handlers"></a>
### Пользовательские обработчики вывода

Если вы попытаетесь «отобразить» объект с помощью Blade, будет вызван метод объекта `__toString`. Метод [`__toString`](https://www.php.net/manual/ru/language.oop5.magic.php#language.oop5.magic.tostring) является одним из встроенных в PHP «магических методов». Однако иногда у вас может не быть контроля над методом `__toString` передаваемого класса, например, когда класс, с которым вы взаимодействуете, принадлежит сторонней библиотеке.

В этих случаях Blade позволяет вам зарегистрировать собственный обработчик вывода для конкретного типа объекта. Для этого вы должны вызвать метод `stringable` Blade. Метод `stringable` принимает замыкание. Это замыкание должно получит тип объекта, за отрисовку которого оно отвечает. Как правило, вызов метода `stringable` осуществляется в методе `boot` поставщика `App\Providers\AppServiceProvider`:

    use Illuminate\Support\Facades\Blade;
    use Money\Money;

    /**
     * Загрузка любых служб приложения.
     *
     * @return void
     */
    public function boot()
    {
        Blade::stringable(function (Money $money) {
            return $money->formatTo('en_GB');
        });
    }

После того, как ваш обработчик был определен, вы можете просто вывести объект в своем шаблоне Blade:

```blade
Cost: {{ $money }}
```

<a name="custom-if-statements"></a>
### Пользовательские операторы If

Программирование пользовательской директивы иногда бывает более сложным, чем необходимо при определении простых пользовательских условных операторов. По этой причине Blade содержит метод `Blade::if`, который позволяет быстро определять пользовательские условные директивы с помощью замыканий. Например, давайте определим условие, которое проверяет сконфигурированный по умолчанию «диск» приложения. Мы можем сделать это в методе `boot` поставщика `App\Providers\AppServiceProvider`:

    use Illuminate\Support\Facades\Blade;

    /**
     * Загрузка любых служб приложения.
     *
     * @return void
     */
    public function boot()
    {
        Blade::if('disk', function ($value) {
            return config('filesystems.default') === $value;
        });
    }

После того, как пользовательское условие было определено, вы можете использовать его в своих шаблонах:

```blade
@disk('local')
    <!-- The application is using the local disk... -->
@elsedisk('s3')
    <!-- The application is using the s3 disk... -->
@else
    <!-- The application is using some other disk... -->
@enddisk

@unlessdisk('local')
    <!-- The application is not using the local disk... -->
@enddisk
```
